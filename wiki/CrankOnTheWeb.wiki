#Crank webapplication 1-2-3
= Introduction =
We can all look at the Crank web application example and create a web application using crank. Another is take the blank project and start building using that as our template to start our new crank project. Still to the novice developer jumping into a web application and seeing something we need to know what we are doing. 

The goal here is to take a blank project and make something of it. Walk the developer through simple steps in creating the first web application and do it within an a few hours. Had to find the happy medium between "learn crank in 24 hours" or "crank for dummies".

== Requirements ==
* Jdk 1.5 or higher
* Mysql database
* Maven 2.07 or higher

==Building with Maven==
Some may agree some may not, but Maven 2 proves pretty useful for managing dependencies and the cursed jarmagedon. The basis of the application will be Maven 2 so the first step is download it [http://maven.apache.org/]Maven2. 

Once you have it and know you can use it in your command line you should be off and running. The first thing is look at your project pom.xml. Maven has a typical file structure it likes to follow so following maven's recipe of where java files, templates, resources and the works are important. Break the recipe and instead of cake you have disaster. 

Your maven project folder should mirror or copy the crank examples->blank-project to any location on your computer. Make sure to copy everything in webapp, resources, org/crank to the respective folders

http://krank.googlecode.com/svn/wiki/img/maven-folder-structure.jpg

Now, we have to modify some stuff and understand other things to move forward. The first section is the basic project. We are making a movie database application so we want our project to reflect that. The top of the pom.xml we will change the blank-project stuff over to our application. First remove reference to <parent> pom. by removing this section. The reason is to be independent of building entire crank libraries. The crank libraries for all purposes should have been built already on your local system if your using a snapshot release. (See building crank http://code.google.com/p/krank/wiki/BuildingCrankWithMaven)

Set the group id tag to 'org.crank'; artifact tag group to 'crank-movie'; name of the project 'Crank movie example'. The other tags you can ignore or deletge.
 
The result is the following:

{{{
  <modelVersion>4.0.0</modelVersion>
    
    <groupId>org.crank</groupId>
    <artifactId>crank-movie</artifactId>
    <packaging>war</packaging>
    <version>0.1.0.0-SNAPSHOT</version>
    <name>Crank movie example</name>
}}}

Couple of things to learn about dependencies. Let's start with dependencies in the pom.xml of the blank project:

The first set of dependencies is for spring wiring. Spring if you don't know is an inversion of control container. You can read more about it at [http://www.springframework.org/] Spring's website. The reason we use it in crank is it helps us deal with configurations, allows us to loosely couple the application so that you can use different layers of crank and wire it into some other framework, say you like to use Ibatis over Hibernate, or you want to wire into Struts instead of JSF. 

{{{
  <!-- spring library dependencies -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring</artifactId>
            <version>2.0.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>2.0.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>2.0.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
            <version>2.0.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>2.0.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-support</artifactId>
            <version>2.0.6</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-javaconfig</artifactId>
            <version>1.0-m2</version>
            <exclusions>
                <exclusion>
                    <groupId>asm</groupId>
                    <artifactId>asm-commons</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-support</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.aopalliance</groupId>
                    <artifactId>aopalliance</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-web</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-webmvc</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-aop</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!-- spring aspect libraries -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>2.0.6</version>
        </dependency>
        <dependency>
            <groupId>aopalliance</groupId>
            <artifactId>aopalliance</artifactId>
            <version>1.0</version>
        </dependency>
        <dependency>
            <groupId>aspectj</groupId>
            <artifactId>aspectjrt</artifactId>
            <version>1.5.3</version>
        </dependency>

}}}

The application also needs the ability to log messages to the console or file so to accommodate this and offer the libraries like spring and hibernate dependencies, but at the same time exclude log4j when the application is deployed to an application server container. The following dependency is added:
{{{
<!-- common to multiple layers of application (spring, hibernate)-->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.13</version>
            <scope>provided</scope>
            <exclusions>
                <exclusion>
                    <groupId>avalon-framework</groupId>
                    <artifactId>avalon-framework</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>logkit</groupId>
                    <artifactId>logkit</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
}}}

The next set of dependencies allows crank to use a object-relational mapping framework, or and integrate to the Java Persistence framework (JPA). In this case, it will be hibernate. The other dependency is to the database driver itself to MySQL, and some logging frameworks used by both spring and the apache commons.

Set up your driver dependency for the database, for this exercise this is mysql. 
{{{
  <!-- database driver for mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.0.3</version>
        </dependency>
}}}

Set up some pooling resource dependencies. The application will make use of the apache dbcp library to do this, and some configurations to be covered later. 
{{{
 <!-- database pooling within webapp -->
        <dependency>
            <groupId>commons-dbcp</groupId>
            <artifactId>commons-dbcp</artifactId>
            <version>1.2.2</version>
            <exclusions>
                <exclusion>
                    <groupId>commons-collections</groupId>
                    <artifactId>commons-collections</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.2</version>
        </dependency>
}}}

The final library is hibernate libraries and spring, which allows crank to plugin hibernate and spring together with the JPA framework.
{{{
  <!-- hibernate integration with JPA -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-tools</artifactId>
            <version>3.2.0.beta9a</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
            <version>3.2.1.ga</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-annotations</artifactId>
            <version>3.2.1.ga</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate</artifactId>
            <version>3.2.2.ga</version>
            <scope>compile</scope>
        </dependency>
          <dependency>
            <groupId>asm</groupId>
            <artifactId>asm</artifactId>
            <version>1.5.3</version>
        </dependency>
        <dependency>
            <groupId>org.apache.openjpa</groupId>
            <artifactId>openjpa-persistence-jdbc</artifactId>
            <version>1.0.0</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jpa</artifactId>
            <version>2.0.6</version>
        </dependency>
        <!-- used for hibernate cacheing-->
        <dependency>
            <groupId>net.sf.ehcache</groupId>
            <artifactId>ehcache</artifactId>
            <version>1.3.0</version>
        </dependency>
}}}

After the third party dependencies, add the crank libraries that provides interfaces to these libraries and provides additional support. These are the crank-core, crank-crud, and crank-validation libraries. Crank-core provides support for crank based annotations, utilities used by crank higher level frameworks such as crank-jsf-support, and crank based listeners.

Crank-crud is the bread and butter to cranks create, update, retrieve, delete operations. It provides filter facilities, cacheing, and criteria support. All of these facilities help to make issues with transaction management, sorting and querying information easier for end development. 

The last crank-validation provides annotation support for column, table validation. Some validation features are phone number, email, length, number, and regular expression. These  annotations for validations can be applied to the JPA object, which crank display frameworks can use to validate the data and error to the user messages.
{{{
 <!-- Crank core libraries -->
        <dependency>
            <groupId>org.crank</groupId>
            <artifactId>crank-core</artifactId>
            <version>1.0RC2-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.crank</groupId>
            <artifactId>crank-crud</artifactId>
            <version>1.0RC2-SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.crank</groupId>
            <artifactId>crank-validation</artifactId>
            <version>1.0RC2-SNAPSHOT</version>
        </dependency>
}}}

Unit testing is important and typically with crank, it's been using TestNG. Little more beefier than JUnit. Notice this particular library the scope is set to test as we only want it for unit testing and builds and not the final deployment into the webapplication. The other is spring-mock which allows use of spring mock object when we use unit testing.
{{{
 <!-- unit testing library dependencies -->
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>5.1</version>
            <classifier>jdk15</classifier>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-mock</artifactId>
            <version>2.0.6</version>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-beans</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-context</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-core</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-jdbc</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-jpa</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>org.springframework</groupId>
                    <artifactId>spring-webmvc</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

}}}

This application is going to make use of JSF and crank's support for this. Therefore the following dependencies incorporate servelet support, jsf, and java EL support, and rich faces for ajax capabilities.

{{{
 <dependency>
            <groupId>org.richfaces.ui</groupId>
            <artifactId>richfaces-ui</artifactId>
            <version>3.1.4.GA</version>
            <exclusions>
                <exclusion>
                    <groupId>xerces</groupId>
                    <artifactId>xercesImpl</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>xml-apis</groupId>
                    <artifactId>xml-apis</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>xerces</groupId>
                    <artifactId>xmlParserAPIs</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.richfaces.framework</groupId>
            <artifactId>richfaces-api</artifactId>
            <version>3.1.4.GA</version>
            <exclusions>
                <exclusion>
                    <groupId>xerces</groupId>
                    <artifactId>xercesImpl</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>xml-apis</groupId>
                    <artifactId>xml-apis</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>xerces</groupId>
                    <artifactId>xmlParserAPIs</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.richfaces.framework</groupId>
            <artifactId>richfaces-impl</artifactId>
            <version>3.1.4.GA</version>
            <exclusions>
                <exclusion>
                    <groupId>xerces</groupId>
                    <artifactId>xercesImpl</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>xml-apis</groupId>
                    <artifactId>xml-apis</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>xerces</groupId>
                    <artifactId>xmlParserAPIs</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!-- JSF stuff -->
        <!-- JSF ControllerBean library depenency-->
        <dependency>
            <groupId>poi</groupId>
            <artifactId>poi</artifactId>
            <version>2.5.1-final-20040804</version>
        </dependency>
        <dependency>
            <groupId>org.htmlparser</groupId>
            <artifactId>htmlparser</artifactId>
            <version>1.6</version>
        </dependency>
        <dependency>
            <groupId>joda-time</groupId>
            <artifactId>joda-time</artifactId>
            <version>1.2</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>javax.faces</groupId>
            <artifactId>jsf-api</artifactId>
            <version>1.2_04-p01</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.faces</groupId>
            <artifactId>jsf-impl</artifactId>
            <version>1.2_04-p01</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.4</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>com.sun.facelets</groupId>
            <artifactId>jsf-facelets</artifactId>
            <version>1.1.14</version>
        </dependency>
        <dependency>
            <groupId>el-impl</groupId>
            <artifactId>el-impl</artifactId>
            <version>1.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jstl</artifactId>
            <version>1.1.2</version>
        </dependency>
        <dependency>
            <groupId>commons-validator</groupId>
            <artifactId>commons-validator</artifactId>
            <version>1.3.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>oro</groupId>
            <artifactId>oro</artifactId>
            <version>2.0.8</version>
            <scope>test</scope>
        </dependency>
}}}

Now add the final crank libraries that interface int JSF. This is the crank-jsf-support, which provides the facilities of controllers, validators, and transformers. This library also contains the crank components templates, which are templates that are used to render out listings, fields, and forms. This is the visual things you see when you think of crank. 

The other library is crank-jsf-validation; this provides a number of utilities for JSF validation.

{{{
 <!-- crank jsf presentation layer libraries -->
        <dependency>
            <groupId>org.crank</groupId>
            <artifactId>crank-jsf-support</artifactId>
            <version>1.0RC2-SNAPSHOT</version>
            <exclusions>
                <exclusion>
                    <groupId>javax.el</groupId>
                    <artifactId>el-api</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>el-impl</groupId>
                    <artifactId>el-impl</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>javax.faces</groupId>
                    <artifactId>jsf-api</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>javax.faces</groupId>
                    <artifactId>jsf-impl</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.crank</groupId>
            <artifactId>crank-jsf-validation</artifactId>
            <version>1.0RC2-SNAPSHOT</version>
            <exclusions>
                <exclusion>
                    <groupId>javax.el</groupId>
                    <artifactId>el-api</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>el-impl</groupId>
                    <artifactId>el-impl</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>javax.faces</groupId>
                    <artifactId>jsf-api</artifactId>
                </exclusion>
                <exclusion>
                    <groupId>javax.faces</groupId>
                    <artifactId>jsf-impl</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
}}}

To make builds go by fast and see the application, the project can be run within jetty. A plugin feature in maven allows maven to start up a jetty container and runs the application. It reduces the time to compile, package the application, copy it to a application container's deploy directory, start up the application container, and then see the results. This is much faster when doing debuging than building a whole web application war and deploying it into and application container such as tomcat or jboss. 

Running the application within jetty from maven the command is:

_mvn jetty:run_

Use the batch files in the blank project as other examples for running in debug mode, and connecting to the database. Modify the build section of the pom.xml to have a final name of 'movie-demo'. The build section of the pom should look like this:

{{{
  <build>
        <finalName>movie-demo</finalName>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
        <testResources>
            <testResource>
                <directory>src/test/resources</directory>
                <filtering>true</filtering>
            </testResource>
        </testResources>
        <plugins>
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.mortbay.jetty</groupId>
                <artifactId>maven-jetty-plugin</artifactId>
                <version>6.1.5</version>
                <dependencies>
                    <dependency>
                        <groupId>log4j</groupId>
                        <artifactId>log4j</artifactId>
                        <version>1.2.13</version>
                    </dependency>
                    <dependency>
                        <groupId>javax.faces</groupId>
                        <artifactId>jsf-api</artifactId>
                        <version>1.2_04</version>
                    </dependency>
                    <dependency>
                        <groupId>javax.faces</groupId>
                        <artifactId>jsf-impl</artifactId>
                        <version>1.2_04</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>
}}}

Now, that you've gone through most of the pom.xml for maven all that takes to compile the project is the command:

_mvn clean install_

And you thought life was tough in maven. Obviously there won't be anything yet because there is still the issue you need to write some code.

==Create a Simple table and JPA object==
If you haven't read http://code.google.com/p/krank/wiki/CrankCrudTutorial that may be ok. The fundamentals are there but there are some evolution changes that have happened up to crank 1.0 and we will start from the ground up in building the web application.

The goal of the application is to create a table in a database (mysql), and display its information and allow the user to add, edit, delete, or update data in this. Sounds simple and it should. The data model that the application is going to simulate is a movie database.

First create the database called "crank". (_These are Mysql commands_)
{{{
create database crank;
}}}

Next create a table called "movie". Movie table will have a primary key, created by and date, updated by and date, name, description, ,checked out, year, rating, genre. 

The reason we have all this created data and updated date name and description is not that it's necessary, but allows you to create some sort of history of change to a row in a database table. 

We could allow hibernate to auto generate the table in the database from the annotations on the persistent type object. This is good for development, bad for production release. You run the risk of forgetting you are auto generating tables and when you go to production tables are dropped, data is lost, and you have a big headache. 

{{{
create table `MOVIE` (`MOVIE_ID` int(11) NOT NULL auto_increment,
  `CREATED_BY` varchar(45) default NULL,
  `CREATED_DATE` datetime default NULL,
  `UPDATED_BY` varchar(45) default NULL,
  `UPDATED_DATE` timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP,
  `NAME` varchar(80) default NULL,
  `DESCRIPTION` varchar(255) default NULL,
  `CHECKED_OUT` bit(1) default NULL,
  `YEAR` int(4) default NULL,
  `RATING` varchar(4),
  `GENRE` varchar(30) NOT NULL,
  PRIMARY KEY  (`MOVIE_ID`)
)ENGINE=InnoDB DEFAULT CHARSET=latin1;
}}}

The next thing is to write some code that represents an object of this database. Pretty much if you follow this tutorial http://code.google.com/p/krank/wiki/CrankCrudTutorial on the employee table and apply it to this project you got it. 

Create a MovieBO object and put this in the project src/org/crank/movie/ location.

Here is the solution to how the annotations look. We import the JPA libraries and add annotations of Entity, the table and have the object in this case the MovieBO implement serializable. 

The next are the attributes that we annotate to the columns they represent in the database. 
{{{
package org.crank.movie;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;

/**
 * Child http assertion
 */
@Entity
@Table( name = "MOVIE" )
public class MovieBO implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue( strategy = GenerationType.AUTO )
    @Column( name = "ID" )
    private Long id;
    @Column( name = "CREATED_BY", length = 45 )
    private String createdBy;
    @Temporal( value = TemporalType.TIMESTAMP )
    @Column( name = "CREATED_DATE" )
    private Date createdDate;
    @Column( name = "UPDATED_BY", length = 45 )
    private String updatedBy;
    @Temporal( value = TemporalType.TIMESTAMP )
    @Column( name = "UPDATED_DATE" )
    private Date updatedDate;
     @Column(name="NAME", length=80)
    private String name;
    @Column(name="DESCRIPTION")
    private String description;
     @Column(name="CHECKED_OUT", length=65535)
    private boolean checkedOut;
     @Column(name="YEAR")
    private int year;
    @Column(name="RATING", length=4)
    private int rating;
    @Column(name="GENRE", length=30)
    private String genre;
    ...
}}}

@Entity defines this object as a persistable entity. @Table annotation describes what table this entity object maps to. @Column annotations describe which column in the database each attribute maps. There is a good tutorial on some of this http://www.onjava.com/pub/a/onjava/2007/02/08/an-introduction-to-hibernate-3-annotations.html
and at http://www.hibernate.org

The rest is going to be the access modifier methods which can be auto generated through an IDE (auto generate getter/setter). One difference is the access/modifier for the boolean attribute, this looks like this:
{{{
    public boolean isCheckedOut() {
        return checkedOut;
    }

    public void setCheckedOut(boolean checkedOut) {
        this.checkedOut = checkedOut;
    }

}}}

==Data access object (DAO)===
To run 'queries' and select data sets, you need a data access object. In crank, this can be accomplished by extending facilities used in the crank's GenericDao interface. The GenericDao allows the basic functionality of reads, update, delete, creates of objects. The read facility allows filtering on columns for set values encapsulated in overloaded "find" methods. There is dated documentation on how the finder method's work in the GenericDao. http://code.google.com/p/krank/wiki/UsingDAO

This data access object is going to be a simple, in that it will extend the GenericDao interface. The interface then allows the DAO created to make use of crank's GenericDaoJpa facilities. This code will go in the same package that the MovieBO was placed.

{{{
package org.crank.movie;

import org.crank.crud.GenericDao;

public interface IMovieDao extends GenericDao<MovieBO, Long> {
}
}}}


==Map to persistence==
If everything was copied from the blank crank project there should be in the resources/META-INF/ directory a persistence.xml. This is going to be modified from what is there to suite this project needs.

Change the persistence unit name to "crank-movie". The next is to add the object created above to the persistence unit group so it is accessible. This is required for Hibernate JPA persistence management. This allows hibernate to know which classes are persistable.

<class>org.crank.movie.MovieBO</class>

Solution:
{{{
<?xml version="1.0" encoding="UTF-8"?>
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence 
			http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
    version="1.0">

    <persistence-unit name="crank-movie" transaction-type="RESOURCE_LOCAL">
        <class>org.crank.movie.MovieBO</class>
    </persistence-unit>

</persistence>
}}}

==Modify JPA settings==
After modifying the persistence.xml file, change the jpa.properties file in resources directory. The jpa.properties file is an externalization of the persistence.xml properties. It is possible to have these properties in the persistence.xml and not in a separate file as in this project. As discussed above, it was pointed out that it might not be good to have hibernate auto generate the tables in the database. Change the 'hibernate.hbm2ddl.auto=update' to 'false'.

{{{
openjpa.jdbc.SynchronizeMappings=buildSchema(SchemaAction='add')
openjpa.Log=DefaultLevel=TRACE,SQL=TRACE

hibernate.hbm2ddl.auto=false
hibernate.show_sql=false
hibernate.format_sql=true
hibernate.use_sql_comments=true
hibernate.query.substitutions=true 1, false 0
}}}



==Create A Controller==

==Create A Page==

==See the Results==