#summary Crank Crud Autocompletion Field

= Overview =

If you are new to Crank, this document may not be for you, please see CrankCrudTutorial, GettingStartedWithCrank and CrankCrudDesignDocs first, then come back here.

This document outlines a nifty little feature in Crank - the autocomplete field.  This feature is easy to implement and provides automatic validation based on the underlying data source for the RichFaces suggestion list which the user chooses from.  In its current incarnation, this feature is used for handling Many-to-one form field input and validation.  Here is an example of the feature in action:

http://krank.googlecode.com/svn/wiki/img/autocomplete-sample.png

Here is our task list for setting up and using the autocomplete field:
 # Update `CrankCrudExampleApplicationContext` configuration class, add a wired `autocomplete` controller 
 # Modify the `Employee` form to include Specialty as a form field using the auto-completion attribute syntax
 # Test the field's input and validation behavior
 
== Update `CrankCrudExampleApplicationContext` configuration class, add a wired `autocomplete` controller ==
First we make the changes to `CrankCrudExampleApplicationContext` as follows:
{{{
@Configuration (defaultLazy=Lazy.TRUE)
public abstract class CrankCrudExampleApplicationContext extends CrudJSFConfig {

	...
	    
    @SuppressWarnings("unchecked")
    @Bean (scope = DefaultScopes.SESSION) 
    public Map<String, AutocompleteController> autocomplete () throws Exception {
        Map<String, AutocompleteController> autocomplete = new HashMap<String, AutocompleteController>();

        // Add the data source which contains the auto-complete data
        DaoFilteringDataSource dataSource = new DaoFilteringDataSource();
        dataSource.setDao( repos().get( "Specialty" ));
        
        // Create the auto-complete controller for the particular property on the data source
        // Arguments are:
        //     dataSource -   the data source for the lookup values
        //     propertyName - the property on the lookup results which will be used query against
        //     fieldName -    the field name of the associated entity which will be assigned the  
        //                    validated auto-complete entity upon successful lookup
        AutocompleteController autoController = new AutocompleteController(dataSource, "name", "specialty");
        
        // Wire in the event handler to the associated controller for dealing with 
        // conversion / validation from the Many to One association to the controller's entity
        cruds().get("Employee").getController().addCrudControllerListener(autoController);
        
        // Add to the auto-complete map...
        //     This will be accessed via the field.xhtml as the AutoComplete controller / validator
        //     for the associated property
        autocomplete.put("Specialty", autoController);

        return autocomplete;
    }
        
}}}

The above code snippet wires a `dataSource` which represents the "source" entity for the suggestion list query. The queried field is specified by the `propertyName`.  The `fieldName` represents the field name of the child entity which is value bound to the input text.  

Next, the autocomplete controller must be registered with the entity associated with the suggestion `dataSource`.  This is needed for the auto-validation functionality which we'll discuss in a bit.

Finally, the autocmplete controller is put into scope via the `autocomplete()` map.  The key for this controller represents the token used in the autocomplete form field attribute syntax (explained below).

This completes the changes we needed to make to the `CrankCrudExampleApplicationContext` class.

== Modify the `Employee` form to include `Specialty` as a form field using the auto-completion attribute syntax ==

Next, we have to modify the `Employee` form to include `Specialty` as a form field using the auto-completion attribute syntax which tells the Facelets component to use the RichFaces suggestion box with associated autocomplete controller.  Here is the definition of the expected attribute syntax:

{{{
    <crank:form ...
        propertyNames="[field1],[field2],...,[autocompleteField1:autocompleteController1],..."
        >
	...
}}}

Here is a working example (note the `specialty:Specialty` autocomplete field).  In this example, the autocomplete field is the last field in the `propertyNames` list.  However, you can have as many autocomplete fields at any place in the list and comingled with "normal" fields:

{{{
	<crank:form crud="${crud}" parentForm="employeeForm"
		propertyNames="firstName,lastName,department,description,file,age,numberOfPromotions,specialty:Specialty"
		>
	...
}}}

== Test the field's input and validation behavior ==

As mentioned earlier, the nice thing about the autocomplete field is that the underlying controller will automatically validate the user's selection against the underlying datasource.  Meaning, that although this is rendered as a "free-form" text input field, the result must exist in the provided "parent" data source in order for the value to be updated in the associated "child" entity.  This is achieved by the default behavior of the `AutocompleteController` class which is registered as a contoller listener with the associated child entity in our `CrankCrudExampleApplicationContext` class.  This way, the autocomplete controller can validate the selection during update and create events.

Here is an example of a successfully validated selection:

http://krank.googlecode.com/svn/wiki/img/autocomplete-flow.png

Here is an example of an invalid selection and the associated error:

http://krank.googlecode.com/svn/wiki/img/autocomplete-error.png
