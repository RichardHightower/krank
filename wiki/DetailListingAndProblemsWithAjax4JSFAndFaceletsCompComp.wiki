#summary detailListing problems with Ajax4JSF and Facelets Composition components

Facelets has composition components which are very similar to working with Facelets templates. You can for example pass a composition component ui:defines tag in its body as well at attributes. In the composition component you use named ui:inserts to pull the ui:defines into various parts of the body. The docs for this are a bit sketchy, but I did write a prototype and it worked.

However when using named ui:inserts/ui:defines with Ajax4JSF the named ui:inserts don't seem to work. Tom has documented more about this here and here (TBD).

For example here is how we would like to use detailListing composition component:

{{{
<crank:detailListing detailController="${taskDetailController}"

                    propertyNames="name,startDate,endDate,complete">

	<ui:define name="formBody">

            <h:outputText value="Hello World!" />

        </ui:define>

	<ui:define name="columActions">

 	    <a4j:commandLink action="#{hello.sayHello}" value="hello" >
											  
                  <f:param name="id" value="${row.id}" />
										  
            </a4j:commandLink>

        </ui:define>
		
</crank:detailListing>

}}}

Prototypes of the above technique worked until we combined it with Ajax4JSF. Essentially we are passing two area of the detailController (similar to a facet in JSF), namely the form body and the extra actions we want to show up per row in the listing.


It would have been great if the above worked with Ajax4JSF but it does not. The work around is to submit issues to the Ajax4JSF mailing list and the Facelets mailing list, and then add the following hack until we hear back (last time we submitted something to the Ajax4JSF guys, it was decided that it was a "feature" not a bug):

{{{
<crank:detailListing detailController="${taskDetailController}"
	propertyNames="name,startDate,endDate,complete"
	useFormBody="${true}">

		<h:outputText value="Hello World!" />
	
</crank:detailListing>

}}}

The above passes a form body. Note the use of useFormBody attribute.

{{{
<crank:detailListing detailController="${taskDetailController}"
	propertyNames="name,startDate,endDate,complete"
	useFormBody="${false}">

        <a4j:commandLink action="#{hello.sayHello}" value="hello" >
            <f:param name="id" value="${row.id}" />
        </a4j:commandLink>
	
</crank:detailListing>

}}}

The above passes colum actions. 

The hack works as long as you want a form body or column actions. What if you want both?

Good question. Until we hear back from the JSF heroes over at Facelets and Ajax4JSF we are going to create two tags as follows:

 * <crank:detailForm />
 * <crank:detailTable />

Then you will be able to pass each of these a body and it will get used where apropos. 

If someone else has some other ideas for workaround or better yet a solution to our problem. Please let me know.

For internal team members: We need this for FMT so it has to get done.

==== Sample model ====
Okay so I built out the model as follows:

{{{
...
@Entity
@Inheritance( strategy = InheritanceType.JOINED )
@DiscriminatorColumn( name = "INQUIRY_TYPE_ID", discriminatorType = DiscriminatorType.STRING )
@Table( name = "BASE_INQUIRY" )
public class Inquiry {
	
    @Id
    @GeneratedValue( strategy = GenerationType.AUTO )
	private Long id;
    
	private String name;
...
@Entity
@Inheritance( strategy = InheritanceType.JOINED )
@DiscriminatorColumn( name = "LEAD_TYPE_ID", discriminatorType = DiscriminatorType.STRING )
@Table( name = "BASE_LEAD" )
public class Lead {
    @Id
    @GeneratedValue( strategy = GenerationType.AUTO )	
	private Long id;
    
	private String name;
	
    @ManyToOne
    @JoinColumn( name = "INQUIRY_ID" )
	private Inquiry inquiry;
...
@Entity
@DiscriminatorValue( "PC_INQ" )
public class PetClinicInquiry extends Inquiry {
	private String bb;

...
@Entity
@DiscriminatorValue( "PC_LEAD" )
public class PetClinicLead extends Lead{
...

}}}

Here is the test showing the new DAO/Criteria DSL feature being used.

The first test method shows the nature of the failure we are trying to fix:

{{{
	@Test (groups="reads")
    public void testFailure() {
		long time = System.currentTimeMillis();
		PetClinicInquiry inquiry = new PetClinicInquiry();
		inquiry.setName("inq1");
		inquiry.setBb("ricky" + time);
		this.petClinicInquiryDao.store(inquiry);
		
		PetClinicLead lead = new PetClinicLead();
		lead.setInquiry(inquiry);
		
		this.petClinicLeadDao.store(lead);
		try {
			this.petClinicLeadDao.find(Comparison.eq("inquiry.bb", "ricky" + time));
			fail();
		} catch (Exception ex) {
			/* Unable to run query : SELECT  o 
			 * FROM PetClinicLead o  WHERE  o.inquiry.bb = :inquiry_bb */
			/* java.sql.SQLException: 
			 * Column not found: INQUIRY1_2_.BB in statement
			 * SQL 
			 * select petclinicl0_.id as id4_, petclinicl0_1_.name as name4_, 
			 * petclinicl0_1_.INQUIRY_ID as INQUIRY3_4_ 
			 * from PetClinicLead petclinicl0_ 
			 * inner join BASE_LEAD petclinicl0_1_ 
			 * on petclinicl0_.id=petclinicl0_1_.id, 
			 * BASE_INQUIRY inquiry1_ 
			 * where petclinicl0_1_.INQUIRY_ID=inquiry1_.id 
			 * and inquiry1_2_.bb=?] */			
		}
		
		this.petClinicLeadDao.delete(lead);
		this.petClinicInquiryDao.delete(inquiry);
		
		
    }

}}}

The second test method show that the new feature works:

{{{
	@Test (groups="reads")
    public void testSuccess() {
		long time = System.currentTimeMillis();
		PetClinicInquiry inquiry = new PetClinicInquiry();
		inquiry.setName("inq1");
		inquiry.setBb("ticky" + time);
		petClinicInquiryDao.store(inquiry);
		
		PetClinicLead lead = new PetClinicLead();
		lead.setInquiry(inquiry);
		lead.setName("golden boy" + time);
		
		petClinicLeadDao.store(lead);
		
		List<Object[]> results = petClinicLeadDao.find(Select.select(Select.select("inquiry")), 
					Join.join(Join.entityJoin("PetClinicInquiry", "inquiry")),
					null,
					0,
					1000,
					Comparison.eq("inquiry.bb", true, "ticky" + time));
		
		Object[] objects = results.get(0);
		lead = (PetClinicLead) objects[0];
		inquiry = (PetClinicInquiry) objects[1];
		assertEquals("golden boy" + time, lead.getName());
		assertEquals("inq1", inquiry.getName());
		
		//SELECT  o, inquiry FROM PetClinicLead o, PetClinicInquiry inquiry WHERE  inquiry.bb = :inquiry_bb 
		petClinicLeadDao.delete(lead);
		petClinicInquiryDao.delete(inquiry);
		
		
    }

}}}

The following code:

{{{
List<Object[]> results = petClinicLeadDao.find(Select.select(Select.select("inquiry")), 
		Join.join(Join.entityJoin("PetClinicInquiry", "inquiry")),
		null, 0, 1000, Comparison.eq("inquiry.bb", true, "ticky" + time));

}}}

Generates this query:

{{{
SELECT  o, inquiry FROM PetClinicLead o, PetClinicInquiry inquiry WHERE  inquiry.bb = :inquiry_bb
}}}

The code can be rewritten with static includes for a more DSL feel.

{{{
List<Object[]> results = petClinicLeadDao.find(select(select("inquiry")), 
		join(entityJoin("PetClinicInquiry", "inquiry")),
		null, 0, 1000, eq("inquiry.bb", true, "ticky" + time));

}}}