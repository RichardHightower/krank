#summary Working on a CodeGenerator in Groovy

= Introduction =

You may recall [http://code.google.com/p/krank/wiki/ThinkingInGroovy ThinkingInGroovy] where I shared some experience playing around with Groovy. Well I recently got some funding to work on the code generator again. I dusted off the prototype that I wrote before and start hacking on it again.

This is my fourth code generator. The first code generator that I wrote was at Intel and it was done in JPython. Then a few years later I was at eBlox and wrote a code generator in Jython. Then whilst working at a contract for a big mobile telecom company, I wrote a code generator in Java as a Maven Mojo. (The templates were Velocity.)

So why Groovy.... Well, I really like Groovy. Groovy has what seems to be the best of Python and Java rolled up into a language and syntax that I love. Groovy is what I wished Jython could have been. Note this is a matter of opinion and I am not trying to start a flame war with the Python folks. I still love Python and love programming with it. I just prefer Groovy.

I have poured through the Groovy pragmatic books in hopes to fully utilize the Groovy language and I am doing this write up to see how close I have come to writing "Groovy code".

One area where I have chosen to be less Groovy is in making my methods and closures for the most part strongly typed. I have bad memories of really large Jython/JPython projects that I worked on getting out of hand with regards to typing issues. I like the self documenting nature of declaring methods that take typed arguments. It also helps the IDE give me code completion. So I unapologetically use types in many cases where a more "groovy" programmer would not.

This is a very earlier copy of this project and essentially works well enough to reverse engineer a JPA object model from a database table. I plan on adding Maven Plugin support and a Swing based GUI. Also I plan on adding features like adding classes and relationships from the command line and Swing GUI (even if they do not exist in the database yet).

This code will one day be the basis of code generation support for the Crank and Presto projects.

I have utilized some of the following Groovy language features:

 # Dynamic property access
 # XML writing via builder support
 # XML reading via GPath support
 # Custom closure creating for IoC for doing code cleanup
 # AOP style method decoration for logging via Groovy metaClass, and expando support
 # Category class for adding methods to another class

==Classes in the codegen project==


I would like to start with a brief overview of the classes involved and then discuss some of the Groovy language features that made this project a joy to write.

== Model classes ==
There are a series of model object to represent Java classes, properties and relationships as well as tables, keys, and columns.

Here are the model objects for database tables and Java classes.

|| Class Name || Purpose ||
||      Table       ||    Represents data about a table in a database       || 
||      Key       ||      Represents data about keys in a table (imported and exported)      || 
||      Column       ||    Represents data about a column in a table       || 
||      JavaClass       ||   Represents data about a Java class and how it is mapped to a Table       || 
||      JavaProperty       ||   Represents data about a Java property and how it is mapped to a database column        || 
||      Relationship       ||     Represents data about how Java classes are related      || 





|| Class Name || Purpose ||
|| CodeGenMain           ||   The main entry point into the command line version of the codegen application. Processes command line arguments 
and reads properties file used to configure application. Configure the other classes and performs injection of collaborators.      || 
||  JdbcUtils          ||  Utility class for working with low-level JDBC connections and ResultSets. This class is used a lot by the DataBaseMetaDataReader class.      || 
||  DataBaseMetaDataReader          ||   Used to read database metadata and create a hierarchy of Table, Column and Key model objects. 
The database metadata is read from connection.metaData.getTables, connection.metaData.getColumns, connection.metaData.getPrimaryKeys, connection.metaData.getExportedKeys and connection.metaData.getImportedKeys see Java API docs for JDBC Connection for more detail.      || 
||    JavaModelGenerator        ||   Takes the table hierarchy produced from DataBaseMetaDataReader or read from an XML file and 
generates a hierarchy of JavaClass, JavaProperty and Relationship model objects.     ||  
||    XMLPersister        ||    Reads and writes editable XML files. This allows the end user to override what we guessed in the generation process.     || 
||    CodeGenerator       || Generates *.java files from JavaClass models objects. ||
||    StringCategory      || Adds methods to the String class that are important for code generation. ||

Let's cover the model objects as they are the least interesting and all of the other classes work with them:

{{{
class Table {
	String name    
	List <Column> columns = []
	Set <String> primaryKeys = []
	List <Key> exportedKeys = []
	List <Key> importedKeys = []
	public String toString() {
		"Table (name=${name}, columns=${columns}, primaryKeys=${primaryKeys} )"
	}
}

public class Key{
	Column primaryKey = new Column()
	Column foriegnKey = new Column()
	short updateRule
	short deleteRule
	String fkName
	String pkName
	short deferrability
	boolean imported
	
	String toString() {
		"Key(primaryKey=${primaryKey} \n     foriegnKey=${foriegnKey})"
	}
}

class Column {
	String name
	int type
	String typeName
	boolean nullable=true
	Table table
	boolean primaryKey
	
	public String toString() {
		"Column( name=${name}, table.name=${table?.name})"
	}
	
}

class JavaClass {

    String name
    String packageName
    boolean primitive
    JavaProperty id
    List<JavaProperty> properties = []
    List<Relationship> relationships = []
    HashMap<String, JavaProperty> columnNameToPropertyMap = [:]
    Table table

    public boolean isNamesMatch() {
        return name == table.name;
    }
    
    String toString() {
        "JavaClass name=${name} packageName=${packageName} primitive=${primitive} properties=${properties}"
    }
    
    

}

class JavaProperty {
    JavaClass javaClass
    JavaClass parentClass
    String name
    Column column
    public boolean isNamesMatch() {
        return name == column.name;
    }
    String toString() {
        "JavaProperty(name=${name} javaClass.name=${javaClass.name})"
    }
}

public class Relationship{
	String name
	RelationshipType type
	Key key
	JavaClass relatedClass
	
	public String toString() {
		"Relationship(name=${name}, cardinality=${cardinality}, \n key=%{key})"
	}
}

public enum RelationshipType{
	ONE_TO_ONE, ONE_TO_MANY, MANY_TO_MANY, MANY_TO_ONE, JOINED_SUBCLASS_CHILD, JOINED_SUBCLASS_PARENT;
}

}}}

There is nothing too special about these classes. They are considered POGOs (Plain old Groovy objects). If you don't specify private, protected etc. on a field, it becomes a Java property. (You can't see the getter and setter but they are there). Groovy allows you to use strongly typed properties and I prefer them as they help me document and use the classes that I write. I don't think it makes them less Groovy. 

Notice that the *toString* methods all use GStrings which makes defining *toString* methods a breeze. The GStrings work a bit like JSPs and EL. Notice that you don't need a return statement. The last line in a method is the return statement by default and the "return" statement is optional.

The *RelationshipType* was defined in Groovy but it was causing the maven compiler to puke so I redefined it in Java (renamed the *RelationshipType.groovy* to *RelationshipType.java*) and the Groovy maven plugin could handle it. Groovy comes with a joint compiler that can compile both Java classes and Groovy classes.

== The Groovyness of CodeGenMain ==

The *CodeGenMain* uses these Groovy language features:


 # Dynamic property access
 # AOP style method decoration for logging via Groovy metaClass, and expando support
 # Weaves in a Category class for adding methods to another class


=== Dynamic property access of CodeGenMain ===
The *CodeGenMain* processes the arguments and properties file using the dynamic property access. 

*CodeGenMain* defines these properties:

{{{
public class CodeGenMain{
	String url
	String userName
	String password
	String driver
	String tableNames
	String packageName
	String outputDir
	String appConfigDir
	String xmlFileName
	String propertiesFile
	String debug
	...
}}}

It then processes the arguments with the *processArgs* method as follows:

{{{
	/* Parse the command line arguments. */
	public boolean processArgs (String [] args) {
		boolean invalidArgument = false
		
		String propertyName = null
		String value = null
		/* First pass make sure they passed valid arguments. */
		for (arg in args) {
			if (arg.contains("=")) {
				def command = arg.split("=")
				propertyName = command[0]
				value = command[1]
				if (!this.metaClass.hasProperty(this, propertyName)) {
					invalidArgument = true
					println "Invalid command line argument ${arg}"
				}
				
			}
		}

}}}

Notice it iterates through the *args* and checks to see if the argument passed (password=foo) and checks to see if *CodeGenMain* defines a property called *password* using the *hasProperty* method of the *metaClass* as follows:

{{{
this.metaClass.hasProperty(this, propertyName)
}}}

The *copyPropsFromArgs* method parses the arguments and sets them into *CodeGenMain* using *this\[propertyName\]=value* as follows:
{{{
	public void copyPropsFromArgs(String[] args) {
		actions = []
		for (String arg : args) {
			if (arg.contains("=")) { 
				def command = arg.split("=")
				String propertyName = command[0]
				String value = command[1]
				this[propertyName]=value
				if (debug) println "Processing property ${propertyName}=${value}"
			} else {
				if (availableActions.contains(arg)) {
					if (debug) println "Found action ${arg}"
					actions << arg
				} else {
					println "Action not understood " + arg
				}
			}
		}
	}

}}}

*CodeGenMain* writes to properties using the dynamic properties using *this\[key\] = configProperties\[key\]* and *configProperties\[key\] = this\[key\]* as follows:

{{{
	private void readProperties() {
		configProperties = new Properties()
		File propFile = calculatePropFile()
		if (propFile.exists()) {
			if (debug) println "Found properties file ${propFile}, reading it into application arguments" 
			configProperties.load(new StringReader(propFile.text))
			for (key in configProperties.keySet()) {
				if (configProperties[key]!=null) {
					if (debug) println "overiding values not set: ${key}=${configProperties[key]}"
					this[key] = configProperties[key]
				}
			}
		} else {
			if (debug) println "Properties file not found, so writng new properties file based on arguments passed"
			writeProperties()
		}
	}
	
	private File calculatePropFile () {
		propertiesFile==null ? new File(appConfigDirFile,"config.properties") : new File(propertiesFile) 
	}
	
	private void writeProperties() {
		configProperties = new Properties()
		File propFile = calculatePropFile()
		for (key in this.properties.keySet()) {
			
			Object value = this[key]
			if (value!=null) {
				if (value instanceof String) {
					if (debug ) println "Setting values into properties file ${key} = ${value}"
					configProperties[key] = value
				}
			}
		}
		propFile.parentFile.mkdirs()
		
		propFile.newOutputStream().withStream{stream -> configProperties.store(stream, "prop file") }
	}

}}}

Notice the ability to read and write a properties file in two lines of code with Groovy love and magic (in readProperties and writeProperties) as follows:

{{{
configProperties.load(new StringReader(propFile.text)) //read a properties file in one line of code
...
propFile.newOutputStream().withStream{stream -> configProperties.store(stream, "prop file") } //write a properties file in one line of code
}}}

=== Weaves in a Category class for adding methods to another class ===

The *CodeGenMain* uses the *StringCategory* to add additional methods in the String class as follows:

{{{
	/** This is the main entry point for this program. */
	public static void main (String [] args) {
		use(StringCategory) { 
			CodeGenMain codeGenMain = new CodeGenMain()
			if (codeGenMain.processArgs(args)) {
				codeGenMain.run()
			}
		}
	}
}}}

For references here is the *StringCategory* class:

{{{
package com.arcmind.codegen



/** Adds methods to the String class that are important for code generation.
 *  @author richardhightower
 */
public class StringCategory{

    public static String cap(String self) {
        try {
            return self[0].toUpperCase() + self[1..-1]
        }   catch (Exception ex){
            return self
        }
    }

    public static String capAndLower(String self) {
        try {
            return self[0].toUpperCase() + self[1..-1].toLowerCase()
        }   catch (Exception ex){
            return self
        }
    }

	public static String unCap(String self) {
        try {
            return self[0].toLowerCase() + self[1..-1]
        }   catch (Exception ex){
            return self
        }
	}
	
	public static boolean isAllUppers(String self) {

		boolean notAllUpper = false
		self.each {
		    if (!Character.isUpperCase(it.toCharacter())) {
		        notAllUpper = true
		    }
		}

		return !notAllUpper
	}
	
}

}}}

With the above Category class now the String object has the above methods added to them (even in the code generation templates which are really convenient) as follows:

==== JavaModelGenerator.groovy using new String methods ===
{{{
    String generateName(dbName) {
    	String name
        if (dbName.contains("_")) {
        	name = dbName.split("_").collect{ String namePart -> namePart.capAndLower() }.join()
        } else {
        	if (dbName.isAllUppers()) {
        		name = dbName.capAndLower()
        	} else {
        		name = dbName.cap()
        	}
        }
    	name
    }

}}}

Here is the complete *CodeGenMain* class for reference (I am looking for tips on how to make the code more Groovy): 

{{{
package com.arcmind.codegen



/**
 * The main entry point into the command line version of the codegen application. 
 * Processes command line arguments and reads properties file settings. 
 * Configures the other classes and performs injection of collaborators.
 * @author richardhightower
 */
public class CodeGenMain{
	String url
	String userName
	String password
	String driver
	String tableNames
	String packageName
	String outputDir
	String appConfigDir
	String xmlFileName
	String propertiesFile
	String debug
	File appConfigDirFile
	List <String> actions = []
	Set <String> availableActions = ["reverse", "write", "read", "generate", "all", "help"]
	Properties configProperties
	JdbcUtils jdbcUtils
	DataBaseMetaDataReader reader
	JavaModelGenerator modelGen
	CodeGenerator codeGen
	XMLPersister persister
	List collaborators 
	
	Closure logClosure = {String methodName, methodArgs->
		def validMethod = delegate.metaClass.getMetaMethod(methodName, methodArgs)
		if (validMethod==null) {
			return delegate.metaClass.invokeMissingMethod(delegate, methodName, methodArgs)
		}  else if (validMethod.name=="println") {
			return  validMethod.invoke(delegate, methodArgs)
		}
		System.out.println "Running ${methodName}(${methodArgs})"
		def result = validMethod.invoke(delegate, methodArgs)
		System.out.println "Completed ${methodName}(${methodArgs})"
		result
	}
	
	
	
	public void run() {
		
		if (actions.contains("all")) {
			actions << "reverse" 
			actions << "generate"
			actions << "write"
			actions << "saveProps"
		}
		
		if (actions.contains("help") || actions.empty) {
			help()
		}
		
		if (actions.contains("saveProps")) {
			writeProperties()
		}
		
		/* Read the model from the database or the XML file. */
		if (actions.contains("reverse")) {
			if (debug) println "Reverse engineering the database tables"
			/* Process the database tables */
			reader.jdbcUtils = jdbcUtils        
			reader.processDB()			
			/* Convert the tables into JavaClasses. */
			modelGen.tables = reader.tables
			modelGen.convertTablesToJavaClasses()
		} else if (actions.contains("read")) {
			if (debug) println "Reading XML file"
			persister.read()
			reader.tables = persister.tables
			modelGen.classes = persister.classes
		}
		
		if (actions.contains("generate")) {
			if (debug) println "Generating Java classes"
			/* Output the generated classes. */
			codeGen.classes = modelGen.classes
			codeGen.writeClassFiles()			
		}
		
		if (actions.contains("write")) {
			if (debug) println "Writing XML file containing table and classes model"
			/* Write out xml file. */
			persister.classes = modelGen.classes
			persister.tables = reader.tables
			persister.persist()			
		}
		
		if (debug) println "Success!"
	}
	
	/** This is the main entry point for this program. */
	public static void main (String [] args) {
		use(StringCategory) { 
			CodeGenMain codeGenMain = new CodeGenMain()
			if (codeGenMain.processArgs(args)) {
				codeGenMain.run()
			}
		}
	}
	
	/* Parse the command line arguments. */
	public boolean processArgs (String [] args) {
		boolean invalidArgument = false
		
		String propertyName = null
		String value = null
		/* First pass make sure they passed valid arguments. */
		for (arg in args) {
			if (arg.contains("=")) {
				def command = arg.split("=")
				propertyName = command[0]
				value = command[1]
				if (!this.metaClass.hasProperty(this, propertyName)) {
					invalidArgument = true
					println "Invalid command line argument ${arg}"
				}
				
			}
		}
		
		/* If there are errors do not proceed. */
		if (invalidArgument) {
			println "Problems with command line arguments"
			return false;
		}
		
		/* Read properties from the command line and the properties file. */
		copyPropsFromArgs(args)
		appConfigDirFile = appConfigDir == null ? new File("./codegen") : new File(appConfigDir)
		readProperties()
		copyPropsFromArgs(args) //let the command line args overide the properties file
		
		invalidArgument = configureCollaborators()
		
		if (invalidArgument) {
			println "Unable to configure collaborators"
			return false
		}
		
		return true
		
	}
	
	private boolean configureCollaborators() {
		boolean invalidArgument = false
		
		if (debug) {
			DataBaseMetaDataReader.metaClass.invokeMethod = logClosure
			JavaModelGenerator.metaClass.invokeMethod = logClosure
			CodeGenerator.metaClass.invokeMethod = logClosure			
		}
		
		jdbcUtils = new JdbcUtils()
		codeGen = new CodeGenerator()
		reader = new DataBaseMetaDataReader()
		persister = new XMLPersister()
		modelGen = new JavaModelGenerator()
		
		collaborators = [jdbcUtils, reader, modelGen, codeGen, persister]
		
		/* Configure related classes. */
		jdbcUtils.url = url
		jdbcUtils.userName = userName
		jdbcUtils.driver = driver
		jdbcUtils.password = password == null ? "" : password
		
		/* Collaborator debug configuration. */		
		for (collaborator in collaborators) {
			collaborator.debug = debug == null ? false : Boolean.valueOf(debug)			
		}
		
		
		/* configure tablesNames to process. */ 
		try {
			modelGen.tableNames = tableNames != null ? new HashSet(Arrays.asList(tableNames.split(","))) : [] as HashSet;
		} catch (e) {
			e.printStackTrace()
			invalidArgument = true
			println "Unable to parse tableNames argument ${tableNames}."
		}
		
		
		modelGen.packageName = packageName		
		
		/* Configure output dirs by creating dirs if they do not exist. */
		codeGen.outputDir = outputDir == null ? new File("./target") : new File(outputDir)				
		if (!codeGen.outputDir.isDirectory()) {
			codeGen.outputDir.mkdirs()
		}
		persister.outputDir = appConfigDirFile
		if (!persister.outputDir.isDirectory()) {
			persister.outputDir.mkdirs()
		}
		persister.fileName = xmlFileName == null ? "codegen.xml" : xmlFileName
		
		return invalidArgument
		
	}
	
	private void readProperties() {
		configProperties = new Properties()
		File propFile = calculatePropFile()
		if (propFile.exists()) {
			if (debug) println "Found properties file ${propFile}, reading it into application arguments" 
			configProperties.load(new StringReader(propFile.text))
			for (key in configProperties.keySet()) {
				if (configProperties[key]!=null) {
					if (debug) println "overiding values not set: ${key}=${configProperties[key]}"
					this[key] = configProperties[key]
				}
			}
		} else {
			if (debug) println "Properties file not found, so writng new properties file based on arguments passed"
			writeProperties()
		}
	}
	
	private File calculatePropFile () {
		propertiesFile==null ? new File(appConfigDirFile,"config.properties") : new File(propertiesFile) 
	}
	
	private void writeProperties() {
		configProperties = new Properties()
		File propFile = calculatePropFile()
		for (key in this.properties.keySet()) {
			
			Object value = this[key]
			if (value!=null) {
				if (value instanceof String) {
					if (debug ) println "Setting values into properties file ${key} = ${value}"
					configProperties[key] = value
				}
			}
		}
		propFile.parentFile.mkdirs()
		
		propFile.newOutputStream().withStream{stream -> configProperties.store(stream, "prop file") }
	}
	
	public void copyPropsFromArgs(String[] args) {
		actions = []
		for (String arg : args) {
			if (arg.contains("=")) { 
				def command = arg.split("=")
				String propertyName = command[0]
				String value = command[1]
				this[propertyName]=value
				if (debug) println "Processing property ${propertyName}=${value}"
			} else {
				if (availableActions.contains(arg)) {
					if (debug) println "Found action ${arg}"
					actions << arg
				} else {
					println "Action not understood " + arg
				}
			}
		}
	}
	
	public void help () {
		
		
		println """
	codeGen is used to generate a JPA Java model from a relational database.
	Here are the command line arguments that codeGen takes.

	These are the one that can set parameters, i.e., password=foo.
	They take the form <parameter name>=<value>
	
	Parameters
	appConfigDir	Where to find the config.properties file (defaults to ./codegen)
	propertiesFile  The location of properties where parameters can be stored 
					(defaults to ./codegen/config.properties)

	JDBC/Database Parameters
	url				JDBC URL of database
	userName		User name for JDBC connection
	password		Password for connection
	driver			Driver name for JDBC connection
	tableNames		List of tables names to process
	
	Code Generataion Parameters
	packageName		Package name of clases that will be generated
	outputDir		The output directory of the classes
	xmlFileName		XML file that contains the reversed model
	debug			Puts the app in debug mode

	Command line parameters take precedence over what is stored in the config.properties file.
	All command line arguments can be stored in the properties file using the saveProps action.

	Actions denote what codeGen should do. They do not get passed a parameter.

	reverse			Processes the database into table and classes model
	write			Write the database and classes model into an xml file
	read			Read the XML table and classes model back into memory
	generate		Generate Java classes based on the table and classes model
	all 			Does all of the above
	help			Prints this message
	saveProps		Saves the properties passed to command line to the properties file

	Example 
	codegen.sh all url=jdbc:hsqldb:file:/db-codeGen/testdb userName=sa driver=org.hsqldb.jdbcDriver packageName=org.crank outputDir=./target appConfigDir=./codegen tableNames=Department,Employee
	"""		
	}
	
}

}}}

In 315 short lines of code we process the arguments and read/write configuration properties to the properties file. We also document how to use the command line utility using Groovy here docs.