#summary Crank Validation Design Document

== Introduction ==

This document discusses the current design of the Crank Validation framework.
Specifically it covers the base framework. It does not discuss the Spring MVC or JSF bindings. These will be covered in a seperate document.


== Overview ==

One of the main design principles behind Crank Validation is to allow for a rich set of validation metadata that can be read from annotations, property files, and a database.

The data to configure a validation rule is seperate than the implementation that consumes it. This allows us to swap implementations of design rules to fit a specific set of business requirements. The swapping of one implementation vs another is done primarily with Spring's IoC container, but could easily be done with Guice or some custom IoC/DI container. 

This is a feature that we have use extensibly to customize validation rules based on client's specific requirements. It is felt by the team that this is the only way to go. We can't imagine not using this approach, and don't understand validation frameworks that do not have this seperation of concern (as they usually have less oppurtunity for reuse).

There is not a one to one mapping between Validation Metadata and its corresponding validation rule. This allows us to use compostion to write validation rules.


== Reading Validation Metadata ==

`ValidatorMetaDataReader` is an extention point for reading validation metadata.  There are currently three implmentations framework implementations for this, and a customer specific implementation (that reads the data out of a database for a custom workflow engine) as follows:

 *  `PropertiesFileValidatorMetaDataReader` reads validation metadata from a Java properties file. 
 *  `AnnotationValidatorMetaDataReader` reads the validation metadata from Java 5 Annotation. 
 *  `ChainValidatorMetaDataReader` allows you to configure multiple readers
 

==== UML Class Diagram Showing Validaiton Framework Readers ====
	http://krank.googlecode.com/svn/wiki/img/validation-metadata.png
	
We used `ChainValidatorMetaDataReader` on a project recently to allow validation rules to be written using Annotation, but overriden on a workflow basis based on validation metadata stored in a relational database.
 
== Field Validation ==

We designing field validation we first took a long hard look at other frameworks (WebWork, Tapestry, Spring etc.). None quite fit what we are trying to do and none fit our exact usage. That said, the `FieldValidation` framework relies heavily on the architecture and design of WebWork validation and Tapestry validations. It was inspired the most by those two frameworks. It adds the concept of composition validations. Out of the box it comes with many, many validation rules. One reason it has so many is because it leans on the DI container (Spring but could be Guice) and the composition pattern so you can configure many validation rules without writing code. 

The heart of the Field validaiton framework is the `FieldValidation` interface and the `AbstractValidator` classes. The `CompositeValidator` implements the composition design pattern and let's you configure many validation rules out of other validation rules. There are several rules that simplify working with Regular expressions as well. Notice also the `CommonBridgeValidator` is a bridge to the Apache commons validation framework. You could easily write other bridges, thus allowing you favorite validation framework to use our flexible validation-metadata readers. Please read the comments in the UML diagram as follows:

==== UML Class Diagram Showing Field Validation ====
	http://krank.googlecode.com/svn/wiki/img/field-validation.png

Notice that the validation mappings are not mapped one to one with the number of validation classes. 

==== UML Class Diagram Showing Validation Annotations ====
	http://krank.googlecode.com/svn/wiki/img/annotation-validation.png
	
== Resolving Error Messages ==

The `ValidatorMessage` holds the detail and summary message for validation errors. A `FieldValidator` can produce many `ValidatorMessage`s and returns them via the `ValidatorMessageHolder` (ValidatorMessageHolder validate(Object fieldValue, String fieldLabel)). A `ValidatorMessageHolder` can be either a `ValidatorMessages` which is a group of `ValidationMessage`s or a `ValidationMessage` which is a single `ValidationMessage` illustrated in UML as follows:

==== UML Class Diagram Showing Validation Annotations ====
	http://krank.googlecode.com/svn/wiki/img/validation-message.png


A `FieldValidator` produces `ValidationMessage`. Genereally classes that implement `FieldValidator` produces `ValidationMessage` by using a `MessageSpecification`. To simplify configuration, an `AbstractValidator` is a `MessageSpecification`. Most `FieldValidator` are subclasses of `AbstractValidator`. 

The `MessageSpecification` contains information about how to generate a message.  The `MessageSpecification` knows how to create a message. The `MessageSpecification` will look up the message in the resource bundle if it starts with a "{" (called the I18n Marker). 

The `MessageSpecification` uses `ResourceBundleLocator` to locate a `ResourceBundle`. How a `ResourceBundle` gets located varies for JSF, Spring and our internal custom work flow engine.

If the `message` starts with an I18n Marker (`{`), generate the `key` into the `ResourceBundle`. The `key` is the `message` with the curly brackets pulled off (the '{' and '}' removed). Lookup `message` in the `ResourceBundle` using `subject` and the `key`, i.e., `subject.key`. If the `subject.key` is not found in the `ResourceBundle` then lookup up `message` just using the `key`. If the message key is still not found just return the key as the message. In the case of `FieldValidator`s the subject is the name of the field.

Thus if the field is called `firstName` and the validator is called `required`. First the `message key` `firstName.validator.required` is looked up and then if the `message` is not found then the `message key` `validator.required` is looked up. 

If the message does not have an I18n marker is not in the message, then the `MessageSpecification` still looks up the message in the `ResourceBundle` and if it is not found the original message is returned.

If the `message` does not start with the I18n markers see if it has a '.' in it. If it has a dot, try to look it up using the same technique as before. If it is not found then just return the key as the message. If neither the I18n marker is found or a '.'. 

The arguments for a `MessageSpecification` can be passed at runtime or configured in the application context (or the equivalent in Guice). If arguments are not passed at runtime, `MessageSpecification` checks to if there were arguments configured. If neither arguments are found, it generates an empty argument list. 

The the argument list that is created is not the final argument list. If the subject is not null, a new argument list is created and the `subject`'s label is the first argument (for FieldValidators remember the subject is the field name). The `subject` label is looked up in the `ResourceBundle` and if it not found it is converted from a field name to a human readable name, i.e., if `firstName` is not found in the `ResourceBundle` it is automatically converted to `First Name`. (It gets converted with MessageUtils.getLabel(getSubject(), resourceBundleLocator.getBundle()));)) Lastly, the arguments are applied to the message to produce the I18n enabled message (MessageFormat.format(message, argumentList.toArray())).

The following is illustrated with an activity diagram: 

==== UML Activity Diagram Showing Resolving Error Messages ====
	http://krank.googlecode.com/svn/wiki/img/validation-error-message-resolution.png


== Validation Metadata: Locating validation rules, Copying rule data from validation metadata to `FieldValidation` rules ==
TBD
==== UML Activity Diagram Showing Validation Rule lookup ====
	http://krank.googlecode.com/svn/wiki/img/validation-error-message-resolution.png

==== UML Activity Diagram Showing Copying rule validation data to `FieldValidation` rules ====
	http://krank.googlecode.com/svn/wiki/img/validation-data-to-field-validation.png


== Composition validation logic ==
TBD

==== UML Activity Diagram Showing Composing Validation Rules ====
	http://krank.googlecode.com/svn/wiki/img/validation-data-to-field-validation.png
